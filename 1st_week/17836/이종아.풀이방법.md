# 문제 주소
https://www.acmicpc.net/problem/17836

## 문제 접근 방법
기본적인 미로 문제에 `그람`이라는 요소를 넣어 기존 미로 문제처럼 해결하면 풀리지 않는다.

가장 핵심 요소는 `그람`을 얻었을 때와 얻지 못했을 떄를 구분하여야 한다.

우선 미로 문제에서 최단 경로를 알아내기 위해서는 **BFS**를 사용하여야 한다. 또한, 이미 지나친 곳을 밟지 않기 위해 (무한 루프를 피하기 위해) 밟아온 곳을 저장하는 배열이 필요하다. 나는 `visited`로 정의하였다.

기본적인 미로 문제라면 `visited`를 map과 동일한 2차원 배열로 풀어도 해결된다. 하지만 이 문제에서는 `그람`을 얻었을 때 밟은 곳과 그렇지 않았을 때 밟은 곳을 구분해야 한다. 반례를 들겠다.

```
4 3 100
0 1 2
0 0 0
1 1 1
0 0 0
```

`visited`를 단순 2차원 배열로 처리했을 때 위와 같은 데이터가 들어오면 공주를 구할 수 있음에도 구하지 못하게 된다. 그 이유는 (2, 0)에 있는 `그람`을 얻기 위해 (0, 0) -> (0, 1) -> (1, 1) -> (2, 1) -> (2, 0)을 거치게 되는데 다시 되돌아 가야하는 (2, 1)과 (1, 1)를 이미 방문했기 때문에 지나칠 수 없게 된다.

따라서 `visited`를 `그람`을 얻거나 얻지 못한 경우로 나눈 3차원 배열로 정의했다면 `그람`을 얻었을 때 `visited`는 어떤 곳도 방문하지 않았다. 이렇게 되면 용사가 `그람`이 있는 곳을 시작점으로 하는 단순 미로문제로 바뀐다.

### 시간복잡도
O(N * M)
