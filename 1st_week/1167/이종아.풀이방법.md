# 문제 주소

https://www.acmicpc.net/problem/1167

## 문제 접근 방법

특정 노드를 root로써 시작하여 leaf 노드까지 방문한 뒤, 그 leaf노드를 root로 만들고 다시 leaf노드를 탐색한다. 이 과정을 거치면 시작한 root 노드에서 가장 긴 트리의 지름이 나온다.

하지만 이 문제는 모든 노드에서 나올 수 있는 트리의 지름 중에서 가장 긴 지름을 구해야 한다. 그러나 모든 노드를 방문하면 아마 시간 초과가 발생할 것이다. (해보진 않았지만 아마 그럴 것이다.)

따라서, 방문한 노드들의 index를 set로 묶어 반환한 뒤, 앞으로 방문해야 할 노드들에서 방문했던 노드들을 전부 제거한다. (`index_set -= trace`) 이것이 가능한 이유는 특정 root에서 방문한 어떤 노드에서 시작해도 모두 같은 트리의 지름을 가지기 때문이다.

방문할 노드들이 없을 때까지 반복한 뒤 가장 큰 값을 출력해주는 것으로 문제는 해결된다.

### 시간복잡도

O(N)

### Python Tip

Python에서는 iterable한 데이터를 각각 변수에 담을 수 있다. `a, b, c = [1, 2, 3]` 다음과 같이 작성하면 a, b, c는 각각 1, 2, 3의 값을 가진다.

여기서 만약 특정 index 이후에 값의 길이가 정해져있지 않을 때는 다음과 같이 선언할 수 있다.

`a, *b = [1, 2, 3, 4, 5, 6]` 이와 같이 작성하면 a의 값에는 1이 들어가며 b에는 [2, 3, 4, 5, 6]의 값이 들어가게 된다.

